---
title:  "Data Wrangling and Visualisation in R:  An Introduction to the Tidyverse"
author:  Andy Seaton and Fanny Empacher
output: html_document
---

```{r, setup, results = F, message = F, warning = F, echo = F}

knitr::opts_chunk$set(cache = T, highlight = T)


```

## **Introduction**

This material borrows heavily from the excellent textbook "R for Data Science" by Hadley Wickham.  The textbook is available online for free at http://r4ds.had.co.nz/ 

We encourage you to see these notes as a starting point for further learning - 2 hours is not enough time to learn very much!  

## **Set up**

Create as many R scripts as you feel you need to work through the material.  You can save it all in one long script or save a script for each section.

At the top of each script you should load the required packages and data:

```{r, results = F, message = F, warning = F}
library(ggplot2)   # plotting library
library(dplyr)    # data manipulation
data("airquality")
```


## **Data manipulation**

This section covers five main features of the `dplyr` package

* subset by rows using `filter()`
* subset by columns using `select()`
* create new columns using `mutate()`
* collapse data into summaries using `summarise()`

We will be using the `airquality` data that comes with base R.  To get a feel for a dataset you have not seen before, the `str()` and `head()` functions are useful.  Try running the following and look at the output:

```{r, eval = F}
head(airquality)
str(airquality)
?airquality     # base R datasets come with documentation
```

### **Subset by rows using `filter()`**

`filter()` allows you to subset a dataframe by setting conditions on values in the data.  The first argument is the dataframe, followed by an expression used to filter the data.

```{r}
filter(airquality, Temp < 58)
```

Some things to note here:  we did not have to put the column name in quotation marks as "Temp".  `dplyr` knows the difference.  The above expression `Temp < 58` has returned all rows with temperature less than 58 degrees.

We also see there are some NAs in the data.
We can use the `is.na()` function to explore this further.

```{r, eval = FALSE}
is.na(3)   # returns FALSE because 3 is not NA
is.na(NA)   # returns TRUE
```

We can use this to get rows where a column is `NA`.  For example:

```{r}
filter(airquality, is.na(Solar.R))
```

returns all rows where there is an `NA` in the `Solar.R` column.  


We can filter by exact values, if you want to save the output, instead of just printing to console, use the assignment `<-` operator.  Often we do this if the subset contains more rows than is useful to print.

```{r}
June_data <- filter(airquality, Month == 6)
nrow(June_data)  # a lot of rows to print
head(June_data)  # can have a glance using head()
```

And can include multiple expressions separated by a comma:

```{r}
filter(airquality, Month == 5, Temp < 60)
```

We can build more complicated expressions using logical operators such as `&, |, ==`.

A final useful expression is the `%in%` operator.  This checks whether an object is within a list of possible values.  E.g. to select all May and June data:

```{r, eval = F}
filter(airquality, Month %in% c(5,6))
```

### **Exercises** 

1. Filter the aiquality data to obtain all records in August
2. Further filter the August data to see only records with Temperature between 60 and 65
3. Filter to get all records where Ozone is not `NA`.  HINT:  recall the NOT operator `!`  e.g.  `!(Temp < 60)` is equivalent to `Temp >= 60`    
4. Select all records on the first 5 days of each month.
5. Calling filter() once only, select all records on the first 5 days of June and July

### **Subset by columns using `select()`**

We can filter by columns using the `select()` function. The syntax is similar, the first argument is the dataframe, the following arguments select the columns. 

For example, to select only the Temp column:

```{r}
df <- select(airquality, Temp)
head(df)

```

To select more than one column, separate the names by a comma:

```{r}
df <- select(airquality, Month, Temp)
head(df)

```

You can also use `select()` to drop columns using a `-` sign in front of the column name.  For example, to select all columns except `Month`:

```{r}
df <- select(airquality, -Month)
head(df)
```

To select all columns between `Ozone` and `Temp` you can use the `:` between the column names:

```{r}
df <- select(airquality, Ozone:Temp)
head(df)
```

### **Exercises**

1. Does the ordering of the column names matter?  Try running `select(airquality, Month, Temp)` and `select(airquality, Temp, Month)`
2. Drop all columns between `Ozone` and `Wind`    HINT:  you will need to use `-` and `()` 
3. Try running the following:  `select(airquality, Wind, everything())`.  What is the everything() function doing here?

### **Create new variables using `mutate()`**

`mutate()` is one of `dplyr`'s most powerful functions.  We use it to create new columns derived from existing ones.  Again, the first argument is always the dataframe we are working on (we will see shortly that is very deliberate).  Subsequent arguments are instructions to create new columns.

For example, the `Wind` column has wind speed in units of miles per hour.  To convert this to kilometres per hour, using conversion factor 1 mph = 1.609 kmph, we can do:

```{r}
df <- mutate(airquality, Wind_kmph = 1.609 * Wind)
head(df)
```

Notice how now there is a new column, appended on the end.  The column name is what we declared on the left hand side of the expression `Wind_kmph = 1.609 * Wind`.

The right hand side are the instructions on what numbers to put into the new column.

We can define our own functions and use them within `mutate()`.  For example, below is a function that takes a single number between 5 and 9 as input and returns the month as a word.  

```{r}
month_conversion <- function(x){
  
  if (x == 5) month <- "May"
  else if (x == 6) month <- "June"
  else if (x == 7) month <- "July"
  else if (x == 8) month <- "August"
  else if (x == 9) month <- "September"
  else month <- NA
  
  return(month)
}

month_conversion(6)
```

To use this within mutate, we combine it with `sapply()` which iterates functions over each element of a vector.  So when we supply the `Month` vector, it run this function on each element:

```{r}
df <- mutate(airquality, Month_long = sapply(Month, month_conversion)) 
head(df)
```

If you only want to keep the new variable(s) created, use `transmute()`:

```{r}
df <- transmute(airquality, Month_long = sapply(Month, month_conversion)) 
head(df)
```

You can create any number of new variables at once, separated by a comma.
For example, the two new variables above could be done in one step using:

```{r}
df <- transmute(airquality,
                Wind_kmph = 1.609 * Wind,
                Month_long = sapply(Month, month_conversion)
                )

head(df)

```

### **Exercises**

1.  The `Temp` column is in degrees Farenheit.  Create a new column with temperature in degrees Celsius.  HINT: The conversion formula is  $T_c = \frac{5}{9}(T_f - 32)$
2.  Create a function that takes a number between 5 and 9 and returns which season the month falls under.  e.g.  5 should return "Spring", 6 should return "Summer" etc.
3.  Use this function and `sapply()` to create a new "Season" column

### **Introducing the pipe:  ` %>% `**

The pipe is a powerful way to combine multiple data wrangling steps in a way that is intuitive and readable.  Often there are multiple steps we want to do - e.g. create a new column then use it to filter.  

To avoid having to use `<-` to save our intermediate dataframes, we can chain all the steps together using the pipe ` %>% `

Here is a simple example.  In the above examples, often I had to create an object called `df` and then use `he*ad()` to view the result.  E.g.

```{r, eval = FALSE}
df <- filter(airquality, Month == 5)
head(df)
```

I can do this in one step using the pipe as follows:

```{r}
filter(airquality, Month == 5) %>% 
  head()
```

The pipe ` %>% ` takes the output of the previous function and uses it as the **first argument** of the following function.

This is why all `dplyr` functions always take a dataframe as the first argument, so you can use the pipe to link together multiple steps!

For example, to create a kmph wind speed variable, and then filter by wind speed less than 7 kmph I could do:

```{r}
airquality %>%    # airquality passed as first argument to mutate()
  mutate(Wind_kmph = 1.609 * Wind) %>%      # result of mutate() passed to filter()
  filter(Wind_kmph < 7)
```

If I wanted to save this as a new object, I use the assignment operator at the top:

```{r, eval = F}
result <- airquality %>%
  mutate(Wind_kmph = 1.609 * Wind) %>%
  filter(Wind_kmph < 7)
```

The benifit of writing code like this is that all the steps of the analysis become clear.  Rading from top to bottom I can see that I started with the `airquality` dataframe, then I created a new column using `mutate()` and then I fitered using the new column I created.


To save you typing the Rstudio shortcut for the pipe is Ctrl + Shift + m


### **Summarise using `summarise()`**

Grouping stuff - now using the pipe as well

### **Exercises**

## **Data Visualisation**

The above functions are useful in themselves, but to gain more insights into the data we should combine them with the powerful plotting library `ggplot2`

### **The Grammar of Graphics**

There are three essential elements in the grammar of graphics.

| Element  |      Description     |  Examples |
|----------|------------------|------------|
| Data |  The dataset being plotted | iris, airquality |
| Aesthetics |    Scales onto which we map our data  |  position (x, y), colour, shape, size, fill |
| Geometries | Visual elements in the plot| points, lines, text, bar |

`ggplot` uses these elements to create plots. The basic syntax looks like this:

```{r, eval = F, results = F, message = F, warning = F}
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))
```

### **Example plots **
We now look at some example to show how to apply this basic syntax to real data. As data, we're using the `iris` dataset from base R.

```{r, results = T}
str(iris)
```


#### **1. Scatterplot**

| Element  |Example|
|----------|------------|
| Data |  iris|
| Aesthetics | x =  Sepal.Length, y = Sepal.Width |
| Geometries | points |

```{r, results = T}
ggplot(data = iris) + 
  geom_point(aes(x = Sepal.Length, Sepal.Width))
```

#### **2. Scatterplot and colour**

| Element  |Example|
|----------|------------|
| Data |  iris|
| Aesthetics | x =  Sepal.Length, y = Sepal.Width, colour = Species|
| Geometries | points |

We can place the aesthetics either in the `ggplot` function and set them globally for the whole plot, or in the `geom` function and set them only for that geometry.

```{r, results = T}
ggplot(data = iris, aes(x = Sepal.Length, Sepal.Width)) + 
  geom_point(aes(colour = Species))
```

#### **3. Group and boxplot**

| Element  |Example|
|----------|------------|
| Data |  iris|
| Aesthetics | x = Species, y = Sepal.Length|
| Geometries | points |

```{r, results = T}
ggplot(iris, aes(x = Species, y = Sepal.Length)) + 
  geom_boxplot(fill = "blue")
```

Note that the aesthetic `fill` has not been mapped to any data but was set manually.

### **Exercises**

1. Run the code below. Why are the points not blue? Fix the code so that they are.

```{r, results = F, eval = F}
ggplot(data = iris, aes(x =Sepal.Length, y = Sepal.Width)) + 
  geom_point(mapping = aes(color = "blue"))
```

2. Using `geom_histogram`, make a histogram for one of the continuous columns of the `iris` dataset. Fill it in a colour of your choice.

3. Start with the code from Example 2. Change it so that `Species` is now mapped to `shape` instead of `colour`. Which plot do you find more informative? What happens if you map `Species` to `size`?

4. Start with the code from example 1. Try and include `Petal.Length` by mapping it to the different aesthetics `colour`, `size` and `shape`. How does the behaviour of these aesthetics differ for continuous vs. categorical variables?

5. Another aethetic to add additional variables to the plot are **facets* which split your plot into subplots. 

```{r, results = F, eval = F}
ggplot(data = iris, aes(x =Sepal.Length, y = Sepal.Width)) + 
  geom_point() +
  facet_wrap(~ Species, nrow = 2)
```
What happens when you map `Species` to another aesthetic at the same time?

### **More geometries**

So far, we have seen a scatterplot with `geom_point`, a histogram with `geom_histogram` and a boxplot with `geom_boxplot`. With a new dataset, we'll explore some more advanced geometries.

```{r, eval = T}
data(tips, package = 'reshape2')
str(tips)
```
```{r, eval = T, echo = FALSE}
ggplot(data = tips, aes(x = total_bill, y = tip)) +
  geom_point(aes(color = sex)) +
  geom_smooth()
```

Be careful when using geometries to fit smooth lines or densities. These are great tools for a first exploration but unless you understand exactly how they are generated, do not rely on them for inference.

### **Exercises**

1. Start by making a simple scatterplot with `total_bill` in the x-axis and `tip` on the y-axis. Add a colour aethetic for `time`.

2. Add a linear regression line to the plot by using `geom_smooth(method = "lm")`. What happens when you change the method to `"loess"`? What seems more appropriate for this data?

3. Add a regression line for each of the different times of day. You can do that by adding an aesthetic to `geom_smooth`, for example `aes(colour = time)`. Try other aesthetics like linetype too.

4. Similar to `facet_wrap` in exercise 5 of the previous section, `facet_grid` allows you to do the same thing for two categorical variables. Try adding the following to your plot. What do the empty cells mean?
```{r, results = F, eval = F}
  + facet_grid(time ~ day)
```

5. 




### **Making it pretty**
labels, legends, titles, manual colours (diamonds?), gg_themes, different scales?


### **Advanced Exercises**

These exercises combine the features of `dplyr` and `ggplot2` together.

Pipe + wrangle to get summaries, then pipe into ggplot() to get plot
Introduce some other ggplot geoms here


Plot model outputs as well


## **Further Resources**

See the following resources for more information on the tidyverse
We have just scratched the surface of `dplyr` and `ggplot2` and there are many other packages as well.

* "R for Data Science" by Hadley Wickham, http://r4ds.had.co.nz/
* ggplot2 website - lots of tips and tricks https://ggplot2.tidyverse.org/
* tidyverse website - an overview of other related packages that are designed to help your analysis workflow https://www.tidyverse.org/packages/
* 
* https://stackoverflow.com/ is a great place to search for tidyverse related questions.  Chances are your problem has been encountered before!  Search for package related questions using the tags e.g. [ggplot2]




